generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider  = "postgresql"
  url       = env("DATABASE_URL")
  directUrl = env("DIRECT_URL") // URL direta para migrations (opcional, só precisa se usar Prisma Data Proxy)
}

model User {
  id                      String             @id @default(uuid())
  name                    String?
  email                   String             @unique
  createdAt               DateTime           @default(now())
  updatedAt               DateTime           @updatedAt
  emailVerified           DateTime?
  image                   String?
  age                     Int?
  appUsage                AppUsage?
  description             String?
  fullName                String?
  gender                  Gender?
  profession              String?
  whatsapp                String?
  averageSessionPrice     String?
  clientsPerWeek          String?
  educationOrSpecialty    String?
  yearsOfExperience       String?
  passwordHash            String?
  stripeCustomerId        String?            @unique
  mensagem_enviada        String?
  status_verificacao      StatusVerificacao?
  mensagem_grupo_essencia String?
  preferredLanguage       String?
  notificationsEnabled    Boolean            @default(false)
  accounts                Account[]
  chatSessions            ChatSession[]
  sessions                Session[]
  subscriptions           Subscription[]
  symptomFolders          SymptomFolder[]
  pushSubscriptions       PushSubscription[]
  reminders               Reminder[]

  @@index([mensagem_enviada])
  @@index([status_verificacao])
  @@index([mensagem_grupo_essencia])
  @@index([preferredLanguage])
  @@index([createdAt])
}

model ChatSession {
  id         String        @id @default(uuid())
  userId     String
  startedAt  DateTime      @default(now())
  endedAt    DateTime?
  createdAt  DateTime      @default(now())
  updatedAt  DateTime      @updatedAt
  threadId   String?       @unique
  isFavorite Boolean       @default(false)
  messages   ChatMessage[]
  user       User          @relation(fields: [userId], references: [id], onDelete: Cascade)

  // Índices compostos para otimizar queries de sessões
  @@index([userId, startedAt]) // Busca de sessões por usuário ordenadas por data
  @@index([userId, isFavorite]) // Busca de sessões favoritas
}

model Account {
  id                String  @id @default(uuid())
  userId            String
  type              String
  provider          String
  providerAccountId String
  refresh_token     String?
  access_token      String?
  expires_at        Int?
  token_type        String?
  scope             String?
  id_token          String?
  session_state     String?
  user              User    @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@unique([provider, providerAccountId])
}

model Session {
  id           String   @id @default(uuid())
  sessionToken String   @unique
  userId       String
  expires      DateTime
  user         User     @relation(fields: [userId], references: [id], onDelete: Cascade)
}

model VerificationToken {
  identifier String
  token      String   @unique
  expires    DateTime

  @@unique([identifier, token])
}

model Plan {
  id              String         @id @default(uuid())
  name            String
  stripePriceId   String         @unique
  monthlyLimit    Int?
  createdAt       DateTime       @default(now())
  updatedAt       DateTime       @updatedAt
  active          Boolean        @default(true)
  amount          Int?
  currency        String?
  interval        PlanInterval?
  intervalCount   Int?
  stripeProductId String?
  trialPeriodDays Int?
  hotmartOfferKey String?        @unique
  hotmartId       Int?           @unique
  subscriptions   Subscription[]
}

model Subscription {
  id                   String   @id @default(uuid())
  userId               String
  planId               String
  stripeSubscriptionId String   @unique
  status               String
  currentPeriodStart   DateTime
  currentPeriodEnd     DateTime
  createdAt            DateTime @default(now())
  updatedAt            DateTime @updatedAt
  plan                 Plan     @relation(fields: [planId], references: [id])
  user                 User     @relation(fields: [userId], references: [id], onDelete: Cascade)

  // Índices compostos para otimizar queries frequentes
  @@index([status, currentPeriodEnd]) // Busca de assinaturas ativas
  @@index([userId, status]) // Busca de assinatura por usuário e status
}

model ChatMessage {
  id            String          @id @default(uuid())
  chatSessionId String
  role          ChatMessageRole
  content       String
  createdAt     DateTime        @default(now())
  chatSession   ChatSession     @relation(fields: [chatSessionId], references: [id], onDelete: Cascade)

  @@index([chatSessionId, createdAt])
}

model ChatAnswerCache {
  id             String    @id @default(uuid())
  normalizedKey  String    @unique @db.VarChar(512)
  content        String
  contentLength  Int
  sourceThreadId String?
  createdAt      DateTime  @default(now())
  updatedAt      DateTime  @updatedAt
  expiresAt      DateTime?

  // Índice para limpeza eficiente de cache expirado
  @@index([expiresAt])
}

model LogExecucao {
  id                         String   @id @default(uuid())
  data_execucao              DateTime @default(now())
  total_clientes_processados Int      @default(0)
  total_compras_encontradas  Int      @default(0)
  total_mensagens_enviadas   Int      @default(0)
  status                     String   @default("iniciado")
  created_at                 DateTime @default(now())

  @@index([data_execucao])
  @@map("log_execucoes")
}

model AuditLog {
  id         String   @id @default(uuid())
  adminId    String
  adminEmail String
  action     String
  resource   String
  resourceId String?
  details    String?
  ipAddress  String?
  userAgent  String?
  timestamp  DateTime @default(now())

  @@index([adminId])
  @@index([timestamp])
  @@index([action])
  @@index([resource])
  @@map("audit_logs")
}

model AdminRequest {
  id            String             @id @default(uuid())
  userId        String
  userEmail     String
  userName      String
  reason        String?
  status        AdminRequestStatus @default(PENDING)
  requestedAt   DateTime           @default(now())
  reviewedAt    DateTime?
  reviewedBy    String?
  reviewerEmail String?
  notes         String?

  @@index([status])
  @@index([requestedAt])
  @@index([userEmail])
  @@map("admin_requests")
}

model PopupConfig {
  id            String      @id @default(uuid())
  title         String
  content       String
  imageUrl      String?
  subscribeLink String
  status        PopupStatus @default(ACTIVE)
  createdAt     DateTime    @default(now())
  updatedAt     DateTime    @updatedAt
}

model SymptomFolder {
  id        String         @id @default(uuid())
  userId    String
  name      String
  color     String?
  createdAt DateTime       @default(now())
  updatedAt DateTime       @updatedAt
  notes     String?
  symptoms  SavedSymptom[]
  user      User           @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@index([userId])
  @@index([createdAt])
}

model SavedSymptom {
  id                String         @id @default(uuid())
  folderId          String
  symptom           String
  threadId          String?
  symptomStartPeriod String?       // Período aproximado (ex: "há 2 semanas", "desde janeiro")
  emotionalHistory  String?        // Histórico emocional (texto livre)
  copingStrategy    CopingStrategy? // Como encarou a situação (opções pré-definidas)
  createdAt         DateTime       @default(now())
  updatedAt         DateTime       @updatedAt
  folder            SymptomFolder @relation(fields: [folderId], references: [id], onDelete: Cascade)

  @@index([folderId])
  @@index([createdAt])
}

model n8n_chat_histories {
  id         Int    @id @default(autoincrement())
  session_id String @db.VarChar(255)
  message    Json
}

model PushSubscription {
  id          String   @id @default(uuid())
  userId      String
  endpoint    String   @unique
  p256dh      String   // Chave pública
  auth        String   // Chave de autenticação
  userAgent   String?  // Navegador/dispositivo
  createdAt   DateTime  @default(now())
  updatedAt   DateTime  @updatedAt
  user        User     @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@index([userId])
  @@index([endpoint])
  @@map("push_subscriptions")
}

model Reminder {
  id          String   @id @default(uuid())
  userId      String?  // null = lembrete global (todos os usuários)
  title       String
  message     String
  time        String   // Formato HH:mm (ex: "09:00")
  daysOfWeek  String   // JSON array com dias da semana [0-6] onde 0 = domingo
  active      Boolean  @default(true)
  createdAt   DateTime  @default(now())
  updatedAt   DateTime  @updatedAt
  lastSentAt  DateTime? // Última vez que foi enviado
  user        User?    @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@index([userId])
  @@index([active])
  @@index([time])
  // Índice composto para otimizar busca de lembretes ativos por horário
  @@index([active, time])
  @@map("reminders")
}

enum AppUsage {
  PERSONAL
  PROFESSIONAL
  ADMIN
}

enum Gender {
  MALE
  FEMALE
  NON_BINARY
  PREFER_NOT_TO_SAY
}

enum PlanInterval {
  DAY
  WEEK
  MONTH
  YEAR
}

enum ChatMessageRole {
  USER
  ASSISTANT
}

enum StatusVerificacao {
  ENVIADA
  PROCESSADO
  ERRO
  PENDENTE
}

enum PopupStatus {
  ACTIVE
  INACTIVE
}

enum AdminRequestStatus {
  PENDING
  APPROVED
  REJECTED
}

enum CopingStrategy {
  ACCEPTED_AND_SOUGHT_HELP      // Aceitei e busquei ajuda
  DENIED_INITIALLY              // Neguei inicialmente
  IGNORED_SYMPTOM               // Ignorei o sintoma
  SOUGHT_INFO_ALONE             // Busquei informações sozinho
  SHARED_WITH_FAMILY_FRIENDS    // Compartilhei com familiares/amigos
  OTHER                         // Outro
}
