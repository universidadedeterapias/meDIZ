// prisma/schema.prisma

generator client {
  provider = "prisma-client-js"
  // output   = "/app/generated/prisma-client"
}

datasource db {
  provider  = "postgresql"
  url       = env("DATABASE_URL")
  // directUrl = env("DIRECT_DATABASE_URL")
}

enum AppUsage {
  PERSONAL
  PROFESSIONAL
  ADMIN
}

enum Gender {
  MALE
  FEMALE
  NON_BINARY
  PREFER_NOT_TO_SAY
}

enum PlanInterval {
  DAY
  WEEK
  MONTH
  YEAR
}

enum StatusVerificacao {
  ENVIADA
  PROCESSADO
  ERRO
  PENDENTE
}

enum PopupStatus {
  ACTIVE
  INACTIVE
}

model User {
  id            String        @id @default(uuid())
  name          String?
  email         String        @unique
  emailVerified DateTime?     // obrigatório para o adapter
  passwordHash  String?
  image         String?       // obrigatório para o adapter
  createdAt     DateTime      @default(now())
  updatedAt     DateTime      @updatedAt

  fullName      String?
  whatsapp      String?
  age           Int?
  gender        Gender?
  profession    String?
  appUsage      AppUsage?
  description   String?       @db.Text

  // campos para appusage=professional
  educationOrSpecialty String?
  yearsOfExperience    String?
  clientsPerWeek       String?
  averageSessionPrice  String?
  
  stripeCustomerId     String?        @unique
  
  // CAMPOS para workflows n8n
  mensagem_enviada         String?        // Pode ser texto ou timestamp
  status_verificacao       StatusVerificacao?
  mensagem_grupo_essencia  String?        // Timestamp ou texto da mensagem enviada para grupo essência
  
  // CAMPO para idioma/localização
  preferredLanguage        String?        // ex: 'pt-BR', 'en-US', 'es-ES'
  
  // assinaturas
  subscriptions      Subscription[]
  chatSessions       ChatSession[]
  symptomFolders     SymptomFolder[]

  // relações usadas pelo Auth.js
  accounts      Account[]     // armazena tokens OAuth, etc
  sessions      Session[]     // armazena sessionTokens JWT ou DB
  
  // relações para auditoria
  // auditLogs      AuditLog[] @relation("UserAuditLogs")       // logs de auditoria - temporariamente comentado

  @@index([mensagem_enviada])
  @@index([status_verificacao])
  @@index([mensagem_grupo_essencia])
  @@index([preferredLanguage])
  @@index([createdAt])
}

model ChatSession {
  id          String   @id @default(uuid())
  userId      String
  threadId    String?  @unique
  isFavorite  Boolean  @default(false)
  startedAt   DateTime @default(now())
  endedAt     DateTime?
  createdAt   DateTime @default(now())
  updatedAt   DateTime @updatedAt

  user User @relation(fields: [userId], references: [id], onDelete: Cascade)
}

model Account {
  id                String   @id @default(uuid())
  userId            String
  type              String
  provider          String
  providerAccountId String
  refresh_token     String?
  access_token      String?
  expires_at        Int?
  token_type        String?
  scope             String?
  id_token          String?
  session_state     String?

  user User @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@unique([provider, providerAccountId])
}

model Session {
  id           String   @id @default(uuid())
  sessionToken String   @unique
  userId       String
  expires      DateTime

  user User @relation(fields: [userId], references: [id], onDelete: Cascade)
}

model VerificationToken {
  identifier String
  token      String   @unique
  expires    DateTime

  @@unique([identifier, token])
}

model Plan {
  id               String           @id @default(uuid())
  name             String
  stripePriceId    String           @unique
  stripeProductId  String?          // opcional, se quiser referência ao Product
  amount           Int?              // valor em centavos (unit_amount)
  currency         String?           // 'brl', 'usd', …
  interval         PlanInterval?     // enum: DAY, WEEK, MONTH, YEAR
  intervalCount    Int?              // quantas unidades do intervalo (ex: 3 meses)
  trialPeriodDays  Int?             // se usar trial direto no Price
  active           Boolean          @default(true)  // para ocultar planos inativos
  monthlyLimit     Int?             // seu uso atual de limite de consultas
  createdAt        DateTime         @default(now())
  updatedAt        DateTime         @updatedAt

  subscriptions    Subscription[]
}

model Subscription {
  id                       String    @id @default(uuid())
  userId                   String
  planId                   String
  stripeSubscriptionId     String    @unique
  status                   String
  currentPeriodStart       DateTime
  currentPeriodEnd         DateTime
  createdAt                DateTime  @default(now())
  updatedAt                DateTime  @updatedAt

  user   User   @relation(fields: [userId], references: [id], onDelete: Cascade)
  plan   Plan   @relation(fields: [planId], references: [id])
}

// TABELA para o workflow n8n
model LogExecucao {
  id                           String   @id @default(uuid())
  data_execucao               DateTime @default(now())
  total_clientes_processados  Int      @default(0)
  total_compras_encontradas   Int      @default(0)
  total_mensagens_enviadas    Int      @default(0)
  status                      String   @default("iniciado") // iniciado, em_progresso, concluido, erro
  created_at                  DateTime @default(now())

  @@index([data_execucao])
  @@map("log_execucoes")
}

// Logs de auditoria para ações dos admins
model AuditLog {
  id          String   @id @default(uuid())
  adminId     String
  adminEmail  String
  action      String   // CREATE, UPDATE, DELETE, LOGIN, LOGOUT, etc.
  resource    String   // user, subscription, popup, etc.
  resourceId  String?  // ID do recurso afetado
  details     String?  @db.Text // Detalhes da ação em JSON
  ipAddress   String?
  userAgent   String?
  timestamp   DateTime @default(now())

  // Relacionamento com User (admin) - temporariamente removido para criar tabela
  // admin User @relation("UserAuditLogs", fields: [adminId], references: [id], onDelete: Cascade)

  @@index([adminId])
  @@index([timestamp])
  @@index([action])
  @@index([resource])
  @@map("audit_logs")
}

// Solicitações de acesso admin
model AdminRequest {
  id          String   @id @default(uuid())
  userId      String   // ID do usuário que solicitou
  userEmail   String   // Email do usuário
  userName    String   // Nome do usuário
  reason      String?  @db.Text // Motivo da solicitação
  status      AdminRequestStatus @default(PENDING)
  requestedAt DateTime @default(now())
  reviewedAt  DateTime?
  reviewedBy  String?  // ID do admin que aprovou/rejeitou
  reviewerEmail String? // Email do admin que revisou
  notes       String?  @db.Text // Notas do revisor

  @@index([status])
  @@index([requestedAt])
  @@index([userEmail])
  @@map("admin_requests")
}

enum AdminRequestStatus {
  PENDING
  APPROVED
  REJECTED
}

// Configurações para o pop-up entre pesquisas
model PopupConfig {
  id               String       @id @default(uuid())
  title            String
  content          String       @db.Text
  imageUrl         String?
  subscribeLink    String
  status           PopupStatus  @default(ACTIVE)
  createdAt        DateTime     @default(now())
  updatedAt        DateTime     @updatedAt
}

// Pastas de sintomas salvas pelo usuário
model SymptomFolder {
  id          String         @id @default(uuid())
  userId      String
  name        String
  color       String?        // Cor da pasta (para UI)
  notes       String?        @db.Text // Observações/comentários sobre a pasta
  createdAt   DateTime       @default(now())
  updatedAt   DateTime       @updatedAt
  
  user        User           @relation(fields: [userId], references: [id], onDelete: Cascade)
  symptoms    SavedSymptom[]
  
  @@index([userId])
  @@index([createdAt])
}

// Sintomas salvos dentro de pastas
model SavedSymptom {
  id          String         @id @default(uuid())
  folderId    String
  symptom     String         // Texto do sintoma
  threadId    String?        // Opcional: associação com thread do chat
  createdAt   DateTime       @default(now())
  updatedAt   DateTime       @updatedAt
  
  folder      SymptomFolder  @relation(fields: [folderId], references: [id], onDelete: Cascade)
  
  @@index([folderId])
  @@index([createdAt])
}