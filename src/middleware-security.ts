/**
 * üõ°Ô∏è Middleware de Seguran√ßa - Detec√ß√£o de Inje√ß√£o
 * 
 * Este middleware detecta SQL Injection e Command Injection em requisi√ß√µes HTTP
 * e bloqueia requisi√ß√µes maliciosas antes que alcancem as rotas da API.
 * 
 * IMPORTANTE: Este middleware deve ser importado e usado no middleware.ts principal
 */

import { NextResponse } from 'next/server'
import type { NextRequest } from 'next/server'
import { detectInjection } from '@/lib/security/injection-detector'

/**
 * Middleware de seguran√ßa para detectar inje√ß√µes
 * 
 * @param req - Requisi√ß√£o HTTP
 * @param endpoint - Endpoint sendo acessado
 * @returns null se n√£o houver detec√ß√£o, ou NextResponse com erro 403 se detectado
 */
export async function securityMiddleware(
  req: NextRequest,
  endpoint: string
): Promise<NextResponse | null> {
  // Aplicar apenas em rotas da API
  if (!endpoint.startsWith('/api/')) {
    return null
  }
  
  // Ignorar rotas de webhook (Hotmart, Stripe) e rotas internas de seguran√ßa
  const ignoredRoutes = [
    '/api/hotmart',
    '/api/stripe',
    '/api/webhooks',
    '/api/security/log-injection' // Evita loop - esta rota processa alertas
  ]
  
  if (ignoredRoutes.some(route => endpoint.startsWith(route))) {
    return null
  }
  
  try {
    // Extrair dados da requisi√ß√£o
    const url = req.nextUrl
    const queryParams: Record<string, unknown> = {}
    
    // Extrair query parameters
    url.searchParams.forEach((value, key) => {
      queryParams[key] = value
    })
    
    // Extrair body (apenas para POST, PUT, PATCH)
    // Nota: Em Next.js, n√£o podemos ler o body no middleware sem consumi-lo
    // Por isso, vamos apenas analisar query params e headers no middleware
    // O body ser√° analisado nas rotas API individuais usando um helper
    const body: unknown = null
    
    // Por enquanto, n√£o lemos o body no middleware para evitar consumir o stream
    // A an√°lise do body ser√° feita nas rotas API usando o helper detectInjectionInRoute
    
    // Extrair headers
    const headers: Record<string, string> = {}
    req.headers.forEach((value, key) => {
      headers[key] = value
    })
    
    // Executar detec√ß√£o
    const detections = detectInjection({
      query: Object.keys(queryParams).length > 0 ? queryParams : undefined,
      body,
      headers,
      path: endpoint
    })
    
    // Se n√£o houver detec√ß√£o, continuar normalmente
    if (detections.length === 0) {
      return null
    }
    
    // Detec√ß√£o encontrada - processar alerta de forma ass√≠ncrona
    const primaryDetection = detections[0]
    
    // Extrair informa√ß√µes da requisi√ß√£o
    const ipAddress = req.headers.get('x-forwarded-for')?.split(',')[0] || 
                      req.headers.get('x-real-ip') || 
                      req.headers.get('cf-connecting-ip') ||
                      'unknown'
    const userAgent = req.headers.get('user-agent') || 'unknown'
    
    // Log da detec√ß√£o
    console.warn(`[SecurityMiddleware] üö® INJE√á√ÉO DETECTADA:`, {
      type: primaryDetection.type,
      severity: primaryDetection.severity,
      pattern: primaryDetection.pattern,
      endpoint,
      method: req.method,
      ipAddress
    })
    
    // Enviar alerta de forma ass√≠ncrona (n√£o bloqueia resposta)
    // Usar fetch para chamar API route que roda no Node.js runtime
    const baseUrl = req.nextUrl.origin
    
    // üö´ BLOQUEIO DESATIVADO: Apenas logar sem bloquear
    // Para reativar bloqueio, defina SECURITY_ENABLE_BLOCK=true no .env
    const ENABLE_BLOCK = process.env.SECURITY_ENABLE_BLOCK === 'true'
    
    // Sempre logar detec√ß√µes (para an√°lise)
    fetch(`${baseUrl}/api/security/log-injection`, {
      method: 'POST',
      headers: {
        'Content-Type': 'application/json',
      },
      body: JSON.stringify({
        detection: primaryDetection,
        endpoint,
        method: req.method,
        ipAddress,
        userAgent,
        userId: undefined // Middleware n√£o tem acesso f√°cil ao userId
      })
    }).catch(error => {
      // Log erro mas n√£o falha a requisi√ß√£o
      console.error('[SecurityMiddleware] Erro ao enviar alerta ass√≠ncrono:', error)
    })
    
    // Log da detec√ß√£o (sempre acontece)
    console.warn(`[SecurityMiddleware] üîç Detec√ß√£o registrada (sem bloqueio):`, {
      type: primaryDetection.type,
      pattern: primaryDetection.pattern,
      severity: primaryDetection.severity,
      endpoint,
      value: primaryDetection.details.value?.substring(0, 50)
    })
    
    // Bloquear apenas se explicitamente habilitado
    if (ENABLE_BLOCK) {
      return NextResponse.json(
        {
          error: 'Requisi√ß√£o bloqueada por seguran√ßa',
          message: 'Padr√£o malicioso detectado na requisi√ß√£o',
          code: 'SECURITY_BLOCKED'
        },
        { status: 403 }
      )
    }
    
    // Por padr√£o, apenas logar mas n√£o bloquear
    return null
  } catch (error) {
    console.error('[SecurityMiddleware] Erro no middleware de seguran√ßa:', error)
    // Em caso de erro, n√£o bloquear (fail open)
    return null
  }
}

